---
layout: post
title:  "BOJ(백준) [1260번] DFS와 BFS 파이썬"
date:   2021-01-01 22:10:45
author: Hoon
categories: Algorithm
---

![DFS와BFS문제.PNG](https://github.com/hoon-923/hoon-923.github.io/blob/main/_images/Algorithm/BOJ/1260/DFS%EC%99%80BFS%EB%AC%B8%EC%A0%9C.PNG?raw=true)

[문제링크](https://www.acmicpc.net/problem/1260)

------

**코드**

~~~python
import sys
r = sys.stdin.readline
N,M,V = map(int,r().split())

edge = [[] for _ in range(N+1)]
for _ in range(M):               
	A,B = map(int,r().split())
	edge[A].append(B)
	edge[B].append(A)

for e in edge:              
	e.sort(reverse=True)

def DFS():
	dfs = []
	stack = [V]
	visit = [False for _ in range(N+1)]
	while stack:                    
		node = stack.pop()
		if visit[node]:
			pass
		else:
			visit[node] = True
			dfs.append(node)
			stack += edge[node]
	return dfs

def BFS():
	bfs = [] 
	que = [V]
	visit = [False for _ in range(N+1)]
	visit[V] = True
	while que:
		node = que.pop()
		bfs.append(node)
		for i in reversed(edge[node]):
			if visit[i]:
				continue
			visit[i] = True
			que = [i] + que
	return bfs
	
print(' '.join(map(str,DFS())))
print(' '.join(map(str,BFS())))
~~~

----

**해설**

DFS(깊이 우선 탐색)과 BFS(너비 우선 탐색)을 구현하는 문제이다. `edge` 를 이용하여 노드별 간선에 대한 정보를 담아 이용하였다. 이 문제는 풀어보기 전 DFS와 BFS에 대한 기본적인 개념을 숙지하는 것이 중요하다고 생각 됩니다.

-----

**결과**

![DFS와BFS결과.PNG](https://github.com/hoon-923/hoon-923.github.io/blob/main/_images/Algorithm/BOJ/1260/DFS%EC%99%80BFS%EA%B2%B0%EA%B3%BC.PNG?raw=true)



